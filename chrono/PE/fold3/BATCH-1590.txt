OraclePagingQueryProvider.generateJumpToItemQuery generates an incorrect query
When running a partitioned job that uses JdbcPagingItemReader as the input, some input rows are being omitted and some are being processed twice. This is happening as a result of JdbcPagingItemReader.doJumpToPage attempting to position the reader at the start of that partition (the &amp;apos;read.count&amp;apos; and &amp;apos;read.count.max&amp;apos; properties have been set in the step execution context to delimit the partitions). 
This problem is only seen when the sortKey will cause the rows to be sorted in an order other than the underlying database storage engine returns them (e.g., not the primary clustering key or query-covering index).
The jumpToItemSql that is generated by the query provider looks something like the following:
SELECT * FROM (SELECT customer AS SORT_KEY, ROWNUM as TMP_ROW_NUM FROM batch_input ORDER BY customer ASC) WHERE TMP_ROW_NUM = 30
This does not return the intended result because the assignment of the TMP_ROW_NUM values happens before the sort, so the effect is exactly the same as if the ORDER BY clause was omitted.
A possible workaround is to add another select level so that the sort happens before TMP_ROW_NUM values are assigned:
SELECT * FROM (SELECT SORT_KEY, ROWNUM AS TMP_ROW_NUM FROM (SELECT customer AS SORT_KEY FROM batch_input ORDER BY SORT_KEY ASC)) WHERE TMP_ROW_NUM = 30