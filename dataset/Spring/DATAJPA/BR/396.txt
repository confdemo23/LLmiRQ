CriteriaQuery caching causes problems with Hibernate&apos;s alias name generation in multithreaded environments
In my project, every now and again some Spring Data Repository methods raise a ClassCastException when called. If this happens once, every subsequent call on the same method results in the same exception. The method is then broken until the JVM or the Spring context is restarted.
After investigating further I found out that this is caused by an incorrectly generated query string. In my case this JPA query string is something like 
select generatedAlias0 from Order as generatedAlias0 left join generatedAlias0.product as generatedAlias0 where generatedAlias0=:param0
The generated alias is the same for the root object as well as the join! After taking a closer look at Hibernate&amp;apos;s sources, I found out that Hibernate&amp;apos;s javax.persistence.criteria.CriteriaQuery implementation (CriteriaQueryImpl) is not thread safe. If there are no aliases set on the CriteriaQuery object (=default), alias names are generated on the first call that uses the object. Now, if multiple threads use the CriteriaQuery object at the same time, this can cause incorrectly generated alias names. Since Spring Data JPA repositories use a shared CriteriaQuery object for each query method, this causes problems in multithreaded environments.
JPA does not explicitly require implementations to provide thread safe CriteriaQuery objects. I reproduced this with Hibernate 4.2.5 and 4.1.9. Maybe with other JPA implementations alias generation is implemented differently and thread safe. Either way, unfortunately, Spring Data can not rely on thread safety in this regard. This problem might have been introduced in DATAJPA-71
Investigation notes:
Query generation in Hibernate can found in org.hibernate.ejb.criteria.CriteriaQueryCompiler (line 223). The renderingContext passed is unique for the thread/call (not unique for the CriteriqQuery object)