Incorrect generated code in one of the ITD&apos;s
I have been reading through the Spring Roo in Action book and trying out the example using the latest STS release. I have run the following commands
project --topLevelPackage rooinaction --projectName roogwt --java 6
persistence setup --provider DATANUCLEUS --database GOOGLE_APP_ENGINE 
entity --class ~.server.domain.Task --testAutomatically 
entity --class ~.server.domain.Project --testAutomatically 
focus --class ~.server.domain.Task
field string --fieldName description
field number --fieldName priority --type java.lang.Integer
field boolean --fieldName completed
field date --fieldName dateCreated --type java.util.Date --dateFormat SHORT 
field date --fieldName dateDue --type java.util.Date --dateFormat SHORT 
field date --fieldName dateComplete --type java.util.Date --dateFormat SHORT 
focus --class ~.server.domain.Project
field string --fieldName projectName
field set --fieldName tasks --type ~.server.domain.Task --cardinality ONE_TO_MANY --mappedBy project
I get the following errors in Project_Roo_JavaBean.aj (I have included the generated code below)
// Error: Annotation removal does not allow values to be specified for the annotation (compiler limitation)
  declare @field: * Project.tasks: -@OneToMany(cascade = CascadeType.ALL, mappedBy = "project");
// Type mismatch, cannot convert from Task to Employee
        for (Employee entity : tasks) {
Interestingly Employee has come from somewhere. This is a brand new STS install STS 2.5.2 Release e3.6.1
The code for Project_Roo_JavaBean.aj
// WARNING: DO NOT EDIT THIS FILE. THIS FILE IS MANAGED BY SPRING ROO.
// You may push code into the target .java compilation unit if you wish to edit any member(s).
package rooinaction.server.domain;
import com.google.appengine.api.datastore.Key;
import com.google.appengine.api.datastore.KeyFactory;
import java.lang.String;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.persistence.CascadeType;
import javax.persistence.OneToMany;
import javax.persistence.Transient;
import rooinaction.server.domain.Task;
privileged aspect Project_Roo_JavaBean {
    declare @field: * Project.tasks: -@OneToMany(cascade = CascadeType.ALL, mappedBy = "project");
    declare @field: * Project.tasks: @Transient;
    private Set&lt;Key&gt; Project.tasksKeys = new HashSet&lt;Key&gt;();
    public String Project.getProjectName() 
{
        return this.projectName;
    }

    public void Project.setProjectName(String projectName) 
{
        this.projectName = projectName;
    }

    public Set&lt;Task&gt; Project.getTasks() {
        Set&lt;rooinaction.server.domain.Task&gt; localTasks = new HashSet&lt;rooinaction.server.domain.Task&gt;();
        for (Key key : tasksKeys) {
            rooinaction.server.domain.Task entity = Task.findTask(key.getId());
            if (entity != null) 
{
                localTasks.add(entity);
            }
        }
        this.tasks = localTasks;
        return localTasks;
    }
    public void Project.setTasks(Set&lt;Task&gt; tasks) {
        Set&lt;rooinaction.server.domain.Task&gt; localTasks = new HashSet&lt;rooinaction.server.domain.Task&gt;();
        List&lt;Long&gt; longIds = new ArrayList&lt;Long&gt;();
        for (Key key : tasksKeys) {
            if (!longIds.contains(key.getId())) 
{
                longIds.add(key.getId());
            }
        }
        for (Employee entity : tasks) {
            if (!longIds.contains(entity.getId())) 
{
                longIds.add(entity.getId());
                tasksKeys.add(KeyFactory.createKey(Task.class.getName(), entity.getId()));
            }
            localTasks.add(entity);
        }
        this.tasks = localTasks;
    }
}
