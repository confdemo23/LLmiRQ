Roo doesn&apos;t hande @Id types different than long
My example contains 3 very simple classes:
//eu.oneview.core.server.domain.PersonProperty
@RooJavaBean
@RooToString
@RooEntity
@MappedSuperclass
public abstract class PersonProperty {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Key						id;
	@ManyToOne
	private Person				person;
	private String				strValue;
	private Date					creationDate;
//...
}
//eu.oneview.core.server.domain.Phone
@RooJavaBean
@RooToString
@RooEntity
public class Phone extends PersonProperty {
}
//eu.oneview.core.server.domain.Person
@RooJavaBean
@RooToString
@RooEntity
public class Person {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Key									key;
	@OneToMany(cascade = CascadeType.ALL)
	private Set&lt;Phone&gt;					phones		= new HashSet&lt;Phone&gt;();
//...
}
the problematic code generated by Roo is on all phone methods, for example:
//eu.oneview.core.server.domain.Person_Roo_JavaBean.aj
// private Set&lt;Key&gt; Person.phonesKeys = new HashSet&lt;Key&gt;(); (is declared as an instance variable)
    public void Person.setPhones(Set&lt;Phone&gt; phones) {
        Set&lt;eu.oneview.core.server.domain.Phone&gt; localPhones = new HashSet&lt;eu.oneview.core.server.domain.Phone&gt;();
        List&lt;Long&gt; longIds = new ArrayList&lt;Long&gt;();
        for (Key key : phonesKeys) {
            if (!longIds.contains(key.getId())) 
{
                longIds.add(key.getId());
            }
        }
        for (Phone entity : phones) {
            if (!longIds.contains(entity.getId())) 
{
                longIds.add(entity.getId());
                phonesKeys.add(KeyFactory.createKey(Phone.class.getName(), entity.getId()));
            }
            localPhones.add(entity);
        }
        this.phones = localPhones;
    }
The problem resides in the assumption that ids are of type long:
List&lt;Long&gt; longIds = new ArrayList&lt;Long&gt;();
Whereas eu.oneview.core.server.domain.Phone_Roo_Entity.aj is generated correctly
    @Transactional
    public static Phone Phone.findPhone(Key id) {
        if (id == null) return null;
        try 
{
            return (Phone) entityManager().createQuery("SELECT o FROM Phone o WHERE o.id = :id").setParameter("id", id).getSingleResult();
        }
 catch (org.springframework.dao.EmptyResultDataAccessException e) 
{
            return null;
        } catch (javax.persistence.NoResultException e) {            return null;        }
    }
the call in eu.oneview.core.server.domain.Person_Roo_JavaBean.aj is:
Phone entity = Phone.findPhone(key.getId()); 
instead of Phone entity = Phone.findPhone(key);
And similar errors are all along the code. 
When doing a &amp;apos;gwt setup&amp;apos;, proxies dont contain the method getId() at all because it&amp;apos;s not in the supported types, this leads to generated code errors:
The method getId() is undefined for the type PhoneProxy	PhoneListEditor.java	/1VuRoo/src/main/java/eu/oneview/core/client/managed/ui	line 85	Java Problem
//eu.oneview.core.client.managed.ui.PhoneListEditor
    @UiHandler("add")
    public void addClicked(ClickEvent e) {
        if (picker.getValue() == null) 
{
            return;
        }
        for (PhoneProxy proxy : displayedList) {
            if (proxy.getId().equals(picker.getValue().getId())) 
{
                return;
            }
        }
        displayedList.add(picker.getValue());
        viewLabel.setText(makeFlatList(displayedList));
    }
I think the easiest way would be to integrate the GAE types to the supported types list (or at least the com.google.appengine.api.datastore.Key type)
Best Regards,
Zied Hamdi