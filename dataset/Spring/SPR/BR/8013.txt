ResourceHttpRequestHandler status code 304 setting Content-Length header
I&amp;apos;ve been debugging an issue while using the Jetty ProxyServlet to proxy all requests to a backend server which uses the mvc:resources namespace element. I finally tracked the issue down to Jetty&amp;apos;s ProxyServlet hanging while waiting for content from the backend server. Originally I thought this was a Jetty issue, but as I look at the HTTP headers, I think it is an issue with ResourceHttpRequestHandler.
ResourceHttpRequestHandler, at line 124 always sets the HTTP headers of Content-Length and Content-Type. Immediately after this call, at line 125, the response is returned if it is found that the resource hasn&amp;apos;t changed and a 304 can be returned. What this means is that a "304 Not Modified" status is returned but the Content-Length header is also set.
I&amp;apos;ve found conflicting reports as to who is in the wrong here, but RFC 2616 section 10.3.5 says,
"If the conditional GET used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers. Otherwise (i.e., the conditional GET used a weak validator), the response MUST NOT include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers."
of course, RFC 2616 section 4.4 says,
"Any response message which "MUST NOT" include a message-body (such as the 1xx, 204, and 304 responses and any response to a HEAD request) is always terminated by the first empty line after the header fields, regardless of the entity-header fields present in the message."
So, in either case (strong or weak validators), it seems like the ResourceHttpRequestHandler should not be setting a Content-Length header because clients could hang waiting for the content. However, clients should be smart enough to ignore content-length header on a 304. This is probably something that should be fixed on both sides!
The forum thread contains a simple workaround where the content length is reset to 0 if a 304 status is set.